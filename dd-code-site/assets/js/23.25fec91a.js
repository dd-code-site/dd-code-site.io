(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{519:function(t,a,v){"use strict";v.r(a);var _=v(6),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),v("p",[t._v("数据库事务 (Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。")]),t._v(" "),v("h2",{attrs:{id:"事务隔离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离"}},[t._v("#")]),t._v(" "),v("strong",[t._v("事务隔离")])]),t._v(" "),v("p",[t._v("同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡转账。")]),t._v(" "),v("h2",{attrs:{id:"数据库事务的四个特性-四种隔离状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务的四个特性-四种隔离状态"}},[t._v("#")]),t._v(" "),v("strong",[t._v("数据库事务的四个特性（四种隔离状态）")])]),t._v(" "),v("p",[t._v("事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("原子性：事务由一个或多个行为捆绑在一起，好像是一个独立的工作单元。原子性保证事务内的操作要么都发生，要么都不发生。假如所有的操作都成功了，那么事务是成功的；假如任何一个操作失败，那么事务就会进行回滚")])]),t._v(" "),v("li",[v("p",[t._v("一致性：一旦一个事务结束了，不管是成功还是失败，系统所处的状态和业务规则是一致的。也就是说，数据应当不会被破坏")])]),t._v(" "),v("li",[v("p",[t._v("隔离性：事务应当允许多个用户操作同一个数据，一个用户的操作不应该和其他用户的操作相混淆。因此事务是相互隔离的，防止并行读写同一个数据的情况发生。注意：隔离性通常意味着要锁定数据库的表或行")]),t._v(" "),v("p",[v("strong",[t._v("不同的隔离级别")]),t._v(" ：")]),t._v(" "),v("ul",[v("li",[t._v("Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生")]),t._v(" "),v("li",[t._v("Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题")]),t._v(" "),v("li",[t._v("Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读")]),t._v(" "),v("li",[t._v("Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题")])])]),t._v(" "),v("li",[v("p",[t._v("持久性：一旦事务完成，事务的结果应当持久化。这样不管什么样的系统崩溃，都不会造成数据异常。")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);